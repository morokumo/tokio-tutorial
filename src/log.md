# もろもろ




## Hello Tokio

- 127.0.0.1:6379 はmini-redis-serverのアドレス
- "".into()　&strをStringにコンバート

- async fn はFuture traitを実装した無名の型を返す
- async fn は .awaitによって初めて実行される．

## Spawining

- 並行(Concurrency)と並列(Parallelism)の違い
    - Concurrency は交互に作業を行うこと　実際の例では，CPUが行う作業がCocurrencyに相当する（実際はParallelismも行うが）．作業者が多くいるわけではない(GPUと比べて)が，1人が行う作業の速度が早いため（CPUの周波数），交互に作業を行ってもそれが成り立つ．
    - Parallelism は２つ以上の作業者が同時に作業を行うこと　GPUではPrallelismであり，それは一つ一つのコアの処理性能が圧倒的に優れているわけではないが，コア(作業者)が多く(CPUと比べて)，同時に作業が行える．

- ↑　わかりづらかったかも
    - 1人が複数の作業を行うのがConcurrencyで
    - 複数人で複数（もしくは一つを分割した作業）を同時に行うのがParallelismがわかりやすい？




## Shared state



- Arcとは？
    - Atomically Reference Counted　（原子的な参照カウント？）の略
    - **スレッドセーフな**参照カウントを使用したスマートポインタである．
    - ヒープ上に割り当てられた共有所有権を提供する
    - cloneを実行すると，参照カウントを増やし，同じヒープ上のアロケーション（割り当て）を指す新しいインスタンスが生成される．
    - 参照カウントが０になると値は破棄される
    - Rustの共有参照はデフォルトでは変更が許されない．したがって，変更の必要がある場合にはArc<Mutex<T>>などを利用する必要がある．Mutexの他にはRwLockやAtomicを使用することができる．
    - ちなみに，非同期で処理したい場合はArc<Mutex<T>>を用い，シングルスレッドの場合にはArc<RefCell<T>>が良い模様？　RefCellにはSyncではないため，さらにArcはスレッドセーフを保証するため，Rcに比べパフォーマスが低い



- ところでスレッドセーフとは？？？
    - 端的にいえば複数のスレッドで同時に並行（Parallelism）で作業を行っても問題が発生しない，つまり安全であるということ．



- Arcは良いけどRcって？
    - Reference Counting （参照カウント）の略
    - スレッドセーフ**ではない**参照カウントを使用したスマートポインタである．
    - 基本的なことはArcと同じ?




- 参照カウントって？
    - メモリオブジェクトのライフサイクル（寿命）管理に使用される方式のひとつ
    - 要するにオブジェクトに対する参照（ポインタ）がいくつ存在するかのカウント
    - ただし，オブジェクトへの参照が変化するたびに値は変更される
    - このカウントが０になった時点でオブジェクトの破棄が許容される（許容されるだけであって常に破棄されるわけではない，実装による？）
    - pros
        - 仕組みが単純である為，高速である．
        - 参照の破棄の検知が迅速に行われる為，メモリが少ない場合に於いては有用な場合がある．
        - 
    - cons
        -　



- Mutexとはなんぞや
    - Mutual exclusion(相互排他)の略
    - Mutex<T>はスマートポインタである．厳密には.lock()がMutexGuardというスマートポインタを返却する．
    - Deref
    - Drop



    - アクセスは常に一つのスレッドに限定される
    - 次の二つのことを覚えておく必要がある．
        1. データを使用する前にロックの獲得を試みなければならない
        2. データをロックし，処理が終わった後，ロックを解除しなければならない

- Derefとは
    - トレイト
    - 参照外し演算子`*`の振る舞いを変更することができる．
    - 


- ところで　COW Copy-On-Writeって？
    - 最適化戦略の一種
    - 要するに，コピーを要求された時に，愚直にコピーを行った場合において，コピーされたもの（またはコピー元）に変更が加えられなかった場合，その処理自体（コピー）の意味がなくなってしまい，計算の無駄が生じてしまう．したがって，それを回避するために，コピー元の参照を取るようにし，見かけ上はコピーという振る舞いをみせ，実際に変更が加えられる際にコピーを行うことによって，無駄な計算を回避する最適化戦略である．
    - 


- シャーディングってなに
    - DBの負荷分散手法






- References
    - https://rustforbeginners.hatenablog.com/entry/arc-mutex-design-pattern
    - https://ja.wikipedia.org/wiki/コピーオンライト
## Channels


## I/O

## Framing


## Async in depth

## Select


## Streams
